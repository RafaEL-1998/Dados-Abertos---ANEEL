import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from pandas.conftest import skipna
from pandas.core.interchange.dataframe_protocol import Column
import datetime

# === CONFIGURA√á√ïES ===
pd.set_option('display.max_columns', None)
plt.style.use('seaborn-v0_8')

# ajuste o nome do seu arquivo
arquivo = "interrupcoes_filtrado.csv"

# === 1. Carregar os dados ===
print("üîç Carregando base de dados...")
df = pd.read_csv(arquivo, sep=';', encoding='latin1', low_memory=False)
base_original = len(df)

# === 2. Filtrar colunas de interesse ===
colunas = [
    "NumAno",
    "SigAgente",
    "DscConjuntoUnidadeConsumidora",
    "DscAlimentadorSubestacao",
    "DatInicioInterrupcao",
    "DatFimInterrupcao",
    "DscSubestacaoDistribuicao",
    "NumNivelTensao",
    "DscFatoGeradorInterrupcao",
    "NumUnidadeConsumidora"
]

# === 3. Tratamento vari√°veis quant. e quali. ===
# --- 3.1 Erros na coluna NumUnidadeConsumidora ---
col_valor = 'NumUnidadeConsumidora'

# Todas as colunas, exceto a √∫ltima (para comparar duplicatas)
cols_sem_valor = df.columns[:-1]

# Encontrar duplicatas (baseadas em todas as colunas menos a √∫ltima)
# e remover as que t√™m valor = 1
df_tratado = (
    df.sort_values(by=col_valor, ascending=False)  # mant√©m o maior valor primeiro
      .drop_duplicates(subset=cols_sem_valor, keep='first')  # descarta a duplicata de valor 1
      .reset_index(drop=True)
)

# (opcional) salvar o resultado
df_tratado.to_csv('dados_tratados.csv', sep=';', index=False, encoding='latin1')
df = df_tratado[colunas]
qtd_repetidos = base_original - len(df_tratado)

# --- 3.2 Arrumando a string proveniente da coluna DscFatoGeradorInterrupcao ---

# Origem --> Interna/Externa;
# Tipo --> Programada/N√£o Programada;
# Classe --> Meio ambiente, Falha Operacional, N√£o Classificada, Pr√≥prias do Sistema, Terceiros, Altera√ß√£o e Manuten√ß√£o;
# Causa --> Erro de opera√ß√£o, Servi√ßo mal executado, animais, √°rvore e vegeta√ß√£o, Descarga atmosf√©rica, eros√£o,
# inunda√ß√£o, Vento, desligamento para manuten√ß√£o, desligamento para seguran√ßa, N√£o Idenfificada, Falha de material ou equipamento
# Sobrecarga, Sobretens√£o, Subtens√£o, abalroamento, defeito cliente afetando outros, interfer√™ncia de terceiros,
# liga√ß√£o clandestina, objeto na rede, roubo, vandalismo, para Melhoria e Preventiva;

# Quebrar em at√© 4 partes ‚Äî o "n=3" limita o split a 4 peda√ßos
df[['Origem', 'Tipo', 'Classe', 'Causa']] = (
    df['DscFatoGeradorInterrupcao']
    .str.split('-', n=3, expand=True)
    .fillna('')  # preenche vazios temporariamente
)

# Remover espa√ßos em branco e normalizar capitaliza√ß√£o
df[['Origem', 'Tipo', 'Classe', 'Causa']] = (
    df[['Origem', 'Tipo', 'Classe', 'Causa']]
    .apply(lambda x: x.str.strip().str.title())
)

# Substituir valores inv√°lidos ou vazios
df['Causa'] = df['Causa'].replace({'': np.nan, '-': np.nan})
df['Classe'] = df['Classe'].replace({'': np.nan, '-': np.nan})
df.loc[df["Classe"] == "N√£o Classificada", "Causa"] = "N√£o Classificada"

print(f"‚úÖ Tratamento de dados conclu√≠do: {list(df.columns)}")
print(f"üìä Total de registros: {len(df):,}")
print(f"üóëÔ∏è Retirado(s) {qtd_repetidos} linhas repetidas")

# === 4. Tratar valores ausentes e tipos ===
df = df.dropna(subset=['Causa', 'NumUnidadeConsumidora'])
df['NumUnidadeConsumidora'] = pd.to_numeric(df['NumUnidadeConsumidora'], errors='coerce').fillna(0)

print(f"\n Resumo r√°pido:")

# === 5. Soma total de consumidores afetados ===
total_consumidores = df['NumUnidadeConsumidora'].sum()
print(f"\nüë• Total de consumidores afetados no ano de {df['NumAno'].iloc[0]}: {int(total_consumidores):,}")

# === 6. Causas x Quantidade - Interrup√ß√µes Programadas e N√£o Programadas ===
# Filtra as interrup√ß√µes N√ÉO PROGRAMADAS
df_nao_programadas = df[df['Tipo'].str.upper() == 'N√ÉO PROGRAMADA']
causas_nao_programadas = df_nao_programadas['Causa'].value_counts()
print("\n‚ö° Causas de interrup√ß√µes N√ÉO PROGRAMADAS:")
print(causas_nao_programadas.head(10))

# Filtra as interrup√ß√µes PROGRAMADAS
df_programadas = df[df['Tipo'].str.upper() == 'PROGRAMADA']
causas_programadas = df_programadas['Causa'].value_counts()
print("\nüõ†Ô∏è Principais causas de interrup√ß√£o PROGRAMADAS:")
print(causas_programadas.head(2))

# === 7. Causas que mais afetaram consumidores ===
consumidores_por_causa = df.groupby('Causa')['NumUnidadeConsumidora'].sum().sort_values(ascending=False)
print(f"\nüî• Causas que mais afetaram consumidores em: {df['NumAno'].iloc[0]}")
print(consumidores_por_causa.head(10))

# === 8. Dura√ß√£o das interrup√ß√µes ===
df['DatInicioInterrupcao'] = pd.to_datetime(df['DatInicioInterrupcao'])
df['DatFimInterrupcao'] = pd.to_datetime(df['DatFimInterrupcao'])
df['Duracao_timedelta'] = df['DatFimInterrupcao'] - df['DatInicioInterrupcao']

# --- Converter dura√ß√£o para horas totais (decimal) para facilitar categoriza√ß√£o
df['Duracao_horas'] = df['Duracao_timedelta'].dt.total_seconds() / 3600

# --- Criar categoria baseada nos intervalos desejados
bins = [0, 6, 12, 24, 48, 72, float('inf')]
labels = ['At√© 6h', '6h a 12h', '12h a 24h', '24h a 48h', '48h a 72h', 'Acima de 72h']
df['Duracao_categoria'] = pd.cut(df['Duracao_horas'], bins=bins, labels=labels, right=False)
df['Duracao_categoria'] = df['Duracao_categoria'].astype(str)  # converte de Categorical para string

# --- Contar ocorr√™ncias por categoria
duracao_interrupcoes = df['Duracao_categoria'].value_counts().reindex(labels)

# === 9. Gr√°fico de barras ‚Äî causas mais frequentes ===
plt.figure(figsize=(10,6))
duracao_interrupcoes.plot(kind='bar', color='steelblue')
plt.title('Distribui√ß√£o das interrup√ß√µes por dura√ß√£o')
plt.xlabel('Dura√ß√£o da Interrup√ß√£o')
plt.ylabel('Quantidade de Ocorr√™ncias')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

# === 10. Gr√°fico de barras ‚Äî causas mais frequentes ===
plt.figure(figsize=(10,5))
causas_nao_programadas.head(10).plot(kind='bar', color='indianred')
plt.title(f'Principais causas de interrup√ß√µes N√£o Programadas x Ocorr√™ncias em {df['NumAno'].iloc[0]}')
plt.ylabel('Ocorr√™ncias')
plt.xlabel('Causas')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

# === 11. Gr√°fico de barras ‚Äî causas mais frequentes ===
plt.figure(figsize=(10,5))
causas_programadas.head(2).plot(kind='bar', color='steelblue')
plt.title(f'Quantidade de interrup√ß√µes Programadas em {df['NumAno'].iloc[0]}')
plt.ylabel('Ocorr√™ncias')
plt.xlabel('Causas')
plt.xticks(rotation=0, ha='center')
plt.tight_layout()
plt.show()

# === 12. Gr√°fico de barras ‚Äî consumidores afetados por causa ===
plt.figure(figsize=(10,5))
consumidores_por_causa.head(10).plot(kind='bar', color='darkgreen')
plt.title(f'Principais causas que afetaram consumidores em {df['NumAno'].iloc[0]}')
plt.ylabel('Total de consumidores afetados')
plt.xlabel('Causas')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

# === 13. Gr√°fico de pizza ‚Äî propor√ß√£o de consumidores por causa ===
plt.figure(figsize=(8,8))
causas_nao_programadas.head(6).plot(kind='pie', autopct='%1.1f%%', startangle=90)
plt.title(f'Percentual das principais causas nas interrup√ß√µes N√£o Programadas em {df['NumAno'].iloc[0]}')
plt.ylabel('')
plt.tight_layout()
plt.show()

# === 14. Exportar resultados para Excel ===
# Series ‚Üí DataFrame
causas_nao_prog_df = causas_nao_programadas.reset_index()
causas_nao_prog_df.columns = ['Causa', 'Qtd']
causas_prog_df = causas_programadas.reset_index()
causas_prog_df.columns = ['Causa', 'Qtd']
consumidores_por_causa_df = consumidores_por_causa.reset_index()
consumidores_por_causa_df.columns = ['Causa', 'TotalConsumidores']
duracao_interrupcoes_df = duracao_interrupcoes.reset_index()
duracao_interrupcoes_df.columns = ['Duracao', 'Qtd']

with pd.ExcelWriter('analise_interrupcoes_EMS.xlsx', engine='xlsxwriter') as writer:
    df.to_excel(writer, sheet_name='Base Filtrada', index=False)
    causas_nao_prog_df.to_excel(writer, sheet_name='Causas Nao Prog', index=False)
    causas_prog_df.to_excel(writer, sheet_name='Causas Programadas', index=False)
    consumidores_por_causa_df.to_excel(writer, sheet_name='Consumidores por Causa', index=False)
    duracao_interrupcoes_df.to_excel(writer, sheet_name='Duracao ocorrencias', index=False)

print("\nüíæ Resultados salvos em: analise_interrupcoes_EMS.xlsx")
print("‚úÖ An√°lise conclu√≠da com sucesso!")
